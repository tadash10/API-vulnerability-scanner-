import requests
import logging
from typing import List, Dict
from pydantic import BaseModel
from requests.exceptions import RequestException
import argparse
import json

# Set up structured logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class APIDocumentation(BaseModel):
    url: str
    endpoints: List[str]

class CustomAPIScanner:
    def __init__(self, api_doc: APIDocumentation):
        self.api_doc = api_doc

    def scan_endpoint(self, endpoint: str) -> Dict[str, bool]:
        vulnerabilities = {
            'sql_injection': False,
            'xss': False,
            'sensitive_data_exposure': False,
            'token_leakage': False,
            'rate_limiting': False
        }

        # Check SQL Injection
        sql_injection_payloads = ["' OR '1'='1", '" OR "1"="1', "'; DROP TABLE users; --"]
        for payload in sql_injection_payloads:
            try:
                response = requests.get(endpoint, params={'q': payload})
                if "SQL syntax" in response.text or response.status_code == 500:
                    vulnerabilities['sql_injection'] = True
                    logging.info(f"SQL Injection vulnerability detected on {endpoint}")
                    break
            except RequestException as e:
                logging.error(f"Request error during SQL Injection test: {e}")

        # Check XSS
        xss_payloads = ["<script>alert('XSS')</script>", "'><img src=x onerror=alert(1)>", "<img src='x' onerror='alert(1)'>"]
        for payload in xss_payloads:
            try:
                response = requests.get(endpoint, params={'q': payload})
                if payload in response.text:
                    vulnerabilities['xss'] = True
                    logging.info(f"XSS vulnerability detected on {endpoint}")
                    break
            except RequestException as e:
                logging.error(f"Request error during XSS test: {e}")

        # Check Sensitive Data Exposure
        sensitive_data_indicators = ["password", "secret", "token", "api_key"]
        try:
            response = requests.get(endpoint)
            if any(indicator in response.text for indicator in sensitive_data_indicators):
                vulnerabilities['sensitive_data_exposure'] = True
                logging.info(f"Sensitive data exposure detected on {endpoint}")
        except RequestException as e:
            logging.error(f"Request error during sensitive data exposure test: {e}")

        # Token Leakage (placeholder)
        vulnerabilities['token_leakage'] = self.check_token_leakage(endpoint)
        
        # Rate Limiting (placeholder)
        vulnerabilities['rate_limiting'] = self.check_rate_limiting(endpoint)

        return vulnerabilities

    def check_token_leakage(self, endpoint: str) -> bool:
        # Placeholder for token leakage check logic
        logging.info(f"Checking for token leakage on {endpoint} (not yet implemented)")
        return False

    def check_rate_limiting(self, endpoint: str) -> bool:
        # Placeholder for rate-limiting check logic
        logging.info(f"Checking for rate limiting on {endpoint} (not yet implemented)")
        return False

    def analyze_documentation(self) -> None:
        logging.info(f"Analyzing API documentation at {self.api_doc.url}...")
        try:
            response = requests.get(self.api_doc.url)
            response.raise_for_status()
            data = response.json()
            if 'paths' in data:
                for path, methods in data['paths'].items():
                    for method in methods:
                        endpoint = f"{self.api_doc.url}{path}"
                        logging.info(f"Scanning endpoint: {endpoint}")
                        vulnerabilities = self.scan_endpoint(endpoint)
                        logging.info(f"Vulnerabilities found: {vulnerabilities}")
            else:
                logging.error("API documentation does not contain 'paths' key.")
        except RequestException as e:
            logging.error(f"Error fetching or parsing documentation: {e}")

def main():
    parser = argparse.ArgumentParser(description='Custom API Vulnerability Scanner')
    parser.add_argument('url', type=str, help='URL of the API documentation')
    args = parser.parse_args()

    api_doc = APIDocumentation(
        url=args.url,
        endpoints=[]
    )
    scanner = CustomAPIScanner(api_doc)
    scanner.analyze_documentation()

if __name__ == "__main__":
    main()
